#!/usr/bin/env bash
set -euo pipefail

# Constants (repo-aware)
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
REPO_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
BACKUP_DIR="$REPO_DIR/backups"
DB_PATH="$REPO_DIR/backend/db/kalito.db"

# Utilities
err() { printf "\e[31m[!] %s\e[0m\n" "$*" >&2; }
ok()  { printf "\e[32m[✓] %s\e[0m\n" "$*"; }
inf() { printf "\e[36m[→] %s\e[0m\n" "$*"; }

require() {
  command -v "$1" >/dev/null 2>&1 || { err "Missing required command: $1"; exit 1; }
}

human_size() {
  local path="$1"
  if command -v numfmt >/dev/null 2>&1; then
    numfmt --to=iec --suffix=B --format="%.1f" "$(stat -c%s "$path" 2>/dev/null || stat -f%z "$path")"
  else
    # fallback: bytes
    echo "$(stat -c%s "$path" 2>/dev/null || stat -f%z "$path")B"
  fi
}

human_time() {
  local path="$1"
  # GNU stat first, BSD stat fallback
  stat -c '%y' "$path" 2>/dev/null || stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$path"
}

list_backups() {
  # list regular files in BACKUP_DIR, newest first
  find "$BACKUP_DIR" -maxdepth 1 -type f -printf "%T@ %p\n" 2>/dev/null \
    | sort -nr \
    | awk '{ $1=""; sub(/^ /,""); print }'
}

confirm() {
  local prompt="$1"
  read -r -p "$prompt [y/N]: " ans
  [[ "$ans" == "y" || "$ans" == "Y" ]]
}

safety_backup() {
  local ts
  ts="$(date +%F_%H%M%S)"
  local safety="$BACKUP_DIR/kalito.db.SAFETY.$ts.bak"
  if [[ -f "$DB_PATH" ]]; then
    if command -v sqlite3 >/dev/null 2>&1; then
      sqlite3 "$DB_PATH" ".backup '$safety'"
    else
      cp -f -- "$DB_PATH" "$safety"
    fi
    ok "Safety backup created → $safety"
  else
    inf "No current DB at $DB_PATH; skipping safety backup."
  fi
}

integrity_check() {
  if command -v sqlite3 >/dev/null 2>&1; then
    local out
    out="$(sqlite3 "$DB_PATH" 'PRAGMA integrity_check;')"
    if [[ "$out" == "ok" ]]; then
      ok "SQLite integrity_check: ok"
    else
      err "SQLite integrity_check reported: $out"
    fi
  else
    inf "sqlite3 not found; skipping integrity_check."
  fi
}

main() {
  require find
  mkdir -p "$BACKUP_DIR"
  mkdir -p "$(dirname "$DB_PATH")"

  local entries=()
  mapfile -t entries < <(list_backups)
  if (( ${#entries[@]} == 0 )); then
    err "No backups found in $BACKUP_DIR"
    exit 1
  fi

  printf "\n\033[1;36mSelect a backup to restore\033[0m (newest first):\n"
  printf "Backup dir: %s\n\n" "$BACKUP_DIR"

  local i=1
  declare -A index_to_path
  for path in "${entries[@]}"; do
    # pretty print size/time/name
    sz="$(human_size "$path")"
    ts="$(human_time "$path")"
    base="$(basename "$path")"
    printf " %2d) %-40s  %8s   %s\n" "$i" "$base" "$sz" "$ts"
    index_to_path["$i"]="$path"
    ((i++))
    # Show first 30 by default to keep list readable
    if (( i > 30 )); then
      printf " ... (%d more not shown)\n" "$((${#entries[@]} - 30))"
      break
    fi
  done

  printf "\nEnter number to restore (or 'q' to quit): "
  read -r choice
  [[ "$choice" == "q" || "$choice" == "Q" ]] && { inf "Aborted."; exit 0; }

  # Validate selection
  if [[ -z "${index_to_path[$choice]:-}" ]]; then
    err "Invalid selection."
    exit 1
  fi

  local src="${index_to_path[$choice]}"
  printf "\nYou chose:\n  %s\n" "$src"

  if ! confirm "Restore this backup into $DB_PATH ?"; then
    inf "Aborted."
    exit 0
  fi

  # Safety backup of current DB
  safety_backup

  # Stop dangling journal files
  rm -f -- "${DB_PATH}-wal" "${DB_PATH}-shm" || true

  # Restore
  if command -v sqlite3 >/dev/null 2>&1; then
    # Use sqlite3 to copy backup file content into target
    # (open backup as DB and .backup into target path)
    sqlite3 "$src" ".backup '$DB_PATH'"
  else
    cp -f -- "$src" "$DB_PATH"
  fi
  ok "Restored → $DB_PATH"

  # Verify
  integrity_check

  printf "\n\033[1;32mDone.\033[0m You may need to restart your backend if it was running.\n"
}

main "$@"
