# sessions.ts - Chat Session Type Definitions

## Overview
`sessions.ts` defines TypeScript interfaces for managing chat sessions in Kalito. Sessions group related messages together, track AI model selection, store personas, and maintain conversation metadata.

---

## Core Types

### Session (Lines 3-11)

```typescript
export interface Session {
  id: string
  name: string
  model: string | null
  recap: string | null
  persona_id: string | null
  created_at: string
  updated_at: string
  saved?: number  // 0 = ephemeral (default), 1 = saved/persisted
}
```

**Purpose:**
Represents a chat conversation session with its configuration and metadata.

---

## Property Details

### Property: id
```typescript
id: string
```

**What it is:** Unique session identifier

**Example:**
```typescript
id: '1698501234567-abc123'  // Generated by generateId()
```

**Use cases:**
- Database primary key
- URL routing (`/chat/1698501234567-abc123`)
- Message association (FK in messages table)

---

### Property: name
```typescript
name: string
```

**What it is:** User-friendly session name

**Examples:**
```typescript
name: "Dad's Health Consultation"
name: "Medication Questions"
name: "October 2025 Check-in"
name: "Untitled Session"  // Default
```

**Use cases:**
- Session list display
- User organization
- Search/filtering

**Best practices:**
- Allow user to rename
- Auto-generate from first message (e.g., first 50 chars)
- Provide default if user doesn't name

---

### Property: model
```typescript
model: string | null
```

**What it is:** Which AI model is used for this session

**Examples:**
```typescript
model: 'gpt-4-turbo-preview'
model: 'claude-3-opus-20240229'
model: 'llama-3-70b'
model: null  // Not set yet
```

**Why nullable?**
- User may not select model yet
- Can be set later (pick model on first message)
- Allows session creation without model selection

**Use cases:**
- Route requests to correct LLM adapter
- Display model badge in UI
- Track which model generated responses

---

### Property: recap
```typescript
recap: string | null
```

**What it is:** AI-generated summary of the session

**Examples:**
```typescript
recap: "Discussed patient's diabetes management, reviewed medication schedule, and answered questions about diet and exercise."
recap: null  // No recap yet
```

**Generation:**
```typescript
// After session ends or every N messages
const messages = getSessionMessages(session.id)
const recap = await llm.generate({
  messages: [
    { role: 'system', content: 'Summarize this conversation in 1-2 sentences' },
    ...messages
  ]
})

updateSession(session.id, { recap: recap.reply })
```

**Use cases:**
- Session list preview (show recap instead of full history)
- Search (search recap text)
- Quick reminder of what was discussed

---

### Property: persona_id
```typescript
persona_id: string | null
```

**What it is:** Reference to the persona used in this session

**Examples:**
```typescript
persona_id: 'persona-doctor'
persona_id: 'persona-caregiver'
persona_id: null  // No persona (use model's default)
```

**Why nullable?**
- Optional feature (can chat without persona)
- User may not select persona

**Relationship:**
```sql
-- Foreign key to personas table
FOREIGN KEY (persona_id) REFERENCES personas(id) ON DELETE SET NULL
```

**Use cases:**
- Load persona's system prompt
- Display persona badge in UI
- Track which personas are most used

---

### Property: created_at
```typescript
created_at: string
```

**What it is:** When the session was created (ISO 8601 timestamp)

**Example:**
```typescript
created_at: '2025-10-28T10:30:45.123Z'
```

**Use cases:**
- Sort sessions (newest first)
- Display session age
- Analytics (sessions per day)

---

### Property: updated_at
```typescript
updated_at: string
```

**What it is:** When the session was last modified

**Example:**
```typescript
updated_at: '2025-10-28T15:45:12.456Z'
```

**Updates when:**
- New message added
- Session renamed
- Model changed
- Persona changed

**Use cases:**
- Sort by "recently active"
- Show "last active 2 hours ago"
- Detect stale sessions

---

### Property: saved
```typescript
saved?: number  // 0 = ephemeral, 1 = saved
```

**What it is:** Whether the session is permanently saved or temporary

**Values:**
- `0` or `undefined`: **Ephemeral** (auto-delete after X days)
- `1`: **Saved** (keep forever)

**Why number instead of boolean?**
- SQLite convention (no native boolean type)
- `0` = false, `1` = true

**Use cases:**
- Auto-cleanup of ephemeral sessions
- "Save this conversation" button
- Separate saved/unsaved in session list

**Example flow:**
```typescript
// Create ephemeral session (default)
const session = createSession({ name: 'Quick question' })
// session.saved = 0 (or undefined)

// User clicks "Save conversation"
updateSession(session.id, { saved: 1 })

// Cleanup job (runs daily)
deleteSessionsWhere({ saved: 0, updated_at: olderThan(30, 'days') })
```

---

## Complete Session Example

```typescript
const session: Session = {
  id: '1698501234567-abc123',
  name: "Dad's Diabetes Management",
  model: 'gpt-4-turbo-preview',
  recap: "Discussed glucose monitoring, medication timing, and dietary recommendations for type 2 diabetes management.",
  persona_id: 'persona-doctor',
  created_at: '2025-10-28T10:30:45.123Z',
  updated_at: '2025-10-28T15:45:12.456Z',
  saved: 1
}
```

---

## Request Types

### CreateSessionRequest (Lines 13-17)

```typescript
export interface CreateSessionRequest {
  name?: string
  model?: string
  persona_id?: string
}
```

**Purpose:**
Request payload for `POST /api/sessions` to create a new session.

**All fields optional** - allows flexible session creation.

---

#### Property: name
```typescript
name?: string
```

**What it is:** Initial session name

**Examples:**
```typescript
name: "Medication Questions"
name: undefined  // Use default: "Untitled Session"
```

**Default behavior:**
```typescript
const defaultName = 'Untitled Session ' + new Date().toLocaleDateString()
```

---

#### Property: model
```typescript
model?: string
```

**What it is:** Pre-select AI model

**Examples:**
```typescript
model: 'gpt-4-turbo-preview'
model: undefined  // User selects later
```

---

#### Property: persona_id
```typescript
persona_id?: string
```

**What it is:** Pre-select persona

**Examples:**
```typescript
persona_id: 'persona-doctor'
persona_id: undefined  // No persona
```

---

### Complete CreateSessionRequest Example

```typescript
const request: CreateSessionRequest = {
  name: "October Health Check-in",
  model: 'gpt-4-turbo-preview',
  persona_id: 'persona-doctor'
}

const response = await fetch('/api/sessions', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(request)
})

const session: Session = await response.json()
```

---

### UpdateSessionRequest (Lines 19-26)

```typescript
export interface UpdateSessionRequest {
  id: string
  name?: string
  model?: string
  persona_id?: string
  recap?: string
  saved?: number
}
```

**Purpose:**
Request payload for `PUT /api/sessions/:id` to update session.

---

#### Property: id
```typescript
id: string
```

**What it is:** Which session to update

**Example:**
```typescript
id: '1698501234567-abc123'
```

**Note:** Typically not in request body (comes from URL param), but included for type completeness.

---

#### Optional Properties

All other properties are **optional** - only include what you want to change.

**Example: Rename session**
```typescript
const request: UpdateSessionRequest = {
  id: '1698501234567-abc123',
  name: 'Updated Session Name'
  // Don't include model, persona_id, etc. - they stay unchanged
}
```

**Example: Mark as saved**
```typescript
const request: UpdateSessionRequest = {
  id: '1698501234567-abc123',
  saved: 1
}
```

**Example: Change model and persona**
```typescript
const request: UpdateSessionRequest = {
  id: '1698501234567-abc123',
  model: 'claude-3-opus-20240229',
  persona_id: 'persona-caregiver'
}
```

---

## Database Schema

```sql
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  model TEXT,
  recap TEXT,
  persona_id TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  saved INTEGER DEFAULT 0,
  FOREIGN KEY (persona_id) REFERENCES personas(id) ON DELETE SET NULL
);

CREATE INDEX idx_sessions_updated_at ON sessions(updated_at);
CREATE INDEX idx_sessions_saved ON sessions(saved);
```

**Indexes:**
- `updated_at`: Fast sorting by recent activity
- `saved`: Efficient filtering (saved vs ephemeral)

---

## API Endpoints

### GET /api/sessions

**Returns:** List of all sessions

```typescript
router.get('/api/sessions', (req, res) => {
  const sessions = db.prepare(`
    SELECT * FROM sessions 
    ORDER BY updated_at DESC
  `).all()
  
  return okList(res, sessions)
})
```

**Response:**
```json
{
  "version": "1",
  "data": [
    {
      "id": "1698501234567-abc123",
      "name": "Dad's Health",
      "model": "gpt-4-turbo-preview",
      "recap": "Discussed medications...",
      "persona_id": "persona-doctor",
      "created_at": "2025-10-28T10:30:45Z",
      "updated_at": "2025-10-28T15:45:12Z",
      "saved": 1
    }
  ]
}
```

---

### GET /api/sessions/:id

**Returns:** Single session

```typescript
router.get('/api/sessions/:id', (req, res) => {
  const session = db.prepare(`
    SELECT * FROM sessions WHERE id = ?
  `).get(req.params.id)
  
  if (!session) {
    return err(res, 'NOT_FOUND', 'Session not found')
  }
  
  return okItem(res, session)
})
```

---

### POST /api/sessions

**Creates:** New session

```typescript
router.post('/api/sessions', (req, res) => {
  const request: CreateSessionRequest = req.body
  
  const session: Session = {
    id: generateId(),
    name: request.name || 'Untitled Session',
    model: request.model || null,
    recap: null,
    persona_id: request.persona_id || null,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    saved: 0
  }
  
  db.prepare(`
    INSERT INTO sessions (id, name, model, recap, persona_id, created_at, updated_at, saved)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    session.id,
    session.name,
    session.model,
    session.recap,
    session.persona_id,
    session.created_at,
    session.updated_at,
    session.saved
  )
  
  return okItem(res, session, 201)
})
```

---

### PUT /api/sessions/:id

**Updates:** Existing session

```typescript
router.put('/api/sessions/:id', (req, res) => {
  const request: UpdateSessionRequest = req.body
  
  // Build dynamic UPDATE query
  const updates: string[] = []
  const values: any[] = []
  
  if (request.name !== undefined) {
    updates.push('name = ?')
    values.push(request.name)
  }
  if (request.model !== undefined) {
    updates.push('model = ?')
    values.push(request.model)
  }
  if (request.persona_id !== undefined) {
    updates.push('persona_id = ?')
    values.push(request.persona_id)
  }
  if (request.recap !== undefined) {
    updates.push('recap = ?')
    values.push(request.recap)
  }
  if (request.saved !== undefined) {
    updates.push('saved = ?')
    values.push(request.saved)
  }
  
  // Always update updated_at
  updates.push('updated_at = ?')
  values.push(new Date().toISOString())
  
  // Add id for WHERE clause
  values.push(req.params.id)
  
  const result = db.prepare(`
    UPDATE sessions 
    SET ${updates.join(', ')} 
    WHERE id = ?
  `).run(...values)
  
  if (result.changes === 0) {
    return err(res, 'NOT_FOUND', 'Session not found')
  }
  
  const session = db.prepare('SELECT * FROM sessions WHERE id = ?').get(req.params.id)
  return okItem(res, session)
})
```

---

### DELETE /api/sessions/:id

**Deletes:** Session and all its messages

```typescript
router.delete('/api/sessions/:id', (req, res) => {
  const result = db.prepare(`
    DELETE FROM sessions WHERE id = ?
  `).run(req.params.id)
  
  if (result.changes === 0) {
    return err(res, 'NOT_FOUND', 'Session not found')
  }
  
  // Messages cascade-deleted automatically (ON DELETE CASCADE)
  
  return okDeleted(res)
})
```

---

## Usage Patterns

### Pattern 1: Create Session on First Message

```typescript
// Frontend: User sends message without session
async function sendMessage(text: string) {
  let sessionId = currentSessionId
  
  // No active session? Create one
  if (!sessionId) {
    const session = await createSession({
      name: text.slice(0, 50)  // Use first 50 chars as name
    })
    sessionId = session.id
    setCurrentSessionId(sessionId)
  }
  
  // Send message
  await sendMessageToSession(sessionId, text)
}
```

---

### Pattern 2: Auto-Generate Recap

```typescript
// Backend: Update recap after every 10 messages
async function onMessageSent(sessionId: string) {
  const messageCount = getMessageCount(sessionId)
  
  if (messageCount % 10 === 0) {
    const messages = getSessionMessages(sessionId)
    const recap = await generateRecap(messages)
    
    updateSession(sessionId, { recap: recap.reply })
  }
}
```

---

### Pattern 3: Session List UI

```typescript
function SessionList({ sessions }: { sessions: Session[] }) {
  return (
    <ul>
      {sessions.map(session => (
        <li key={session.id}>
          <h3>{session.name}</h3>
          <p className="recap">{session.recap || 'No summary yet'}</p>
          <div className="meta">
            <span className="model">{session.model}</span>
            <span className="date">
              {new Date(session.updated_at).toLocaleDateString()}
            </span>
            {session.saved === 1 && <span className="badge">Saved</span>}
          </div>
        </li>
      ))}
    </ul>
  )
}
```

---

### Pattern 4: Cleanup Ephemeral Sessions

```typescript
// Cron job: Delete ephemeral sessions older than 30 days
async function cleanupEphemeralSessions() {
  const thirtyDaysAgo = new Date()
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
  
  const result = db.prepare(`
    DELETE FROM sessions 
    WHERE saved = 0 
    AND updated_at < ?
  `).run(thirtyDaysAgo.toISOString())
  
  logInfo('Cleaned up ephemeral sessions', {
    deletedCount: result.changes
  })
}

// Run daily
setInterval(cleanupEphemeralSessions, 24 * 60 * 60 * 1000)
```

---

## Best Practices

### 1. Update `updated_at` on Every Change
```typescript
// ✅ Good
function updateSession(id: string, changes: Partial<Session>) {
  changes.updated_at = new Date().toISOString()  // Always update
  // ... perform update
}

// ❌ Bad - stale updated_at
function updateSession(id: string, changes: Partial<Session>) {
  // ... perform update without updating updated_at
}
```

### 2. Provide Meaningful Default Names
```typescript
// ✅ Good
const defaultName = `Session ${new Date().toLocaleString()}`
// "Session 10/28/2025, 10:30 AM"

// ❌ Bad
const defaultName = 'Untitled'  // All sessions have same name
```

### 3. Cascade Delete Messages
```sql
-- ✅ Good - messages deleted automatically
FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE

-- ❌ Bad - orphaned messages
FOREIGN KEY (session_id) REFERENCES sessions(id)
```

### 4. Use Saved Flag for Important Sessions
```typescript
// ✅ Good - let user mark important sessions
<button onClick={() => updateSession(session.id, { saved: 1 })}>
  Save Forever
</button>

// ❌ Bad - delete all sessions
// (User loses important conversations)
```

### 5. Index Frequently Queried Fields
```sql
-- ✅ Good - fast sorting
CREATE INDEX idx_sessions_updated_at ON sessions(updated_at)

-- ❌ Bad - slow queries
-- No index on updated_at (table scan on every list)
```

---

## Summary

**sessions.ts defines chat session management types:**

### Core Type: Session
- **id**: Unique identifier
- **name**: User-friendly name
- **model**: AI model selection (nullable)
- **recap**: AI-generated summary (nullable)
- **persona_id**: Persona reference (nullable)
- **created_at**: Creation timestamp
- **updated_at**: Last modified timestamp
- **saved**: Ephemeral (0) or saved (1)

### Request Types
- **CreateSessionRequest**: Create new session (all optional fields)
- **UpdateSessionRequest**: Update existing session (sparse update)

**Key features:**
- **Flexible creation** (minimal required fields)
- **Partial updates** (only change what's needed)
- **Auto-cleanup** (ephemeral sessions)
- **AI summaries** (recap generation)
- **Model/persona tracking** (conversation context)

**Enables:**
- Multi-conversation management
- Conversation history
- Model/persona switching
- Auto-cleanup of temp conversations
- Session search/filtering
